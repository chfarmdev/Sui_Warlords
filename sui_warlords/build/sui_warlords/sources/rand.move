// This is a psuedo-random number generator; outputs will always be the same number
// given the same ctx (transaction context). Note that the ctx is mutated every time a
// number is generated, so it can be used consecutively in the same transaction, however
// the sequence of random numbers is deterministic.
//
// I don't know of any way for a user to externally "game" this; I believe the UID's
// generated by Sui are very dependent upon the chain itself.
//
// Eventually this should be replaced by a VRF from Switchboard (work in progress)

// https://github.com/void-tech-art/capsules/blob/master/packages/sui_utils/sources/rand.move


module sui_warlords::rand {
    use std::hash;
    use std::vector;
    use sui::bcs;
    use sui::object;
    use sui::clock::{Self, Clock};
    use sui::tx_context::{Self, TxContext};
    use sui_warlords::counter::{Self, Counter};

    const EBAD_RANGE: u64 = 0;
    const ETOO_FEW_BYTES: u64 = 1;    

    public fun rng(min: u64, max: u64, ctx: &mut TxContext): u64 {
        assert!(max >= min, EBAD_RANGE);
        let value = from_seed(seed(ctx));

        value % (max - min) + min
    }

    public fun rng_with_clock(min: u64, max: u64, clock: &Clock, ctx: &mut TxContext): u64 {
        assert!(max > min, EBAD_RANGE);
        let value = from_seed(seed_with_clock(clock, ctx));

        value % (max - min) + min
    }

    public fun rng_with_counter<T>(
        w: &T,
        min: u64,
        max: u64,
        counter: &mut Counter<T>,
        ctx: &mut TxContext
    ): u64 {
        assert!(max > min, EBAD_RANGE);
        let value = from_seed(seed_with_counter(w, counter, ctx));

        value % (max - min) + min
    }

    public fun rng_with_clock_and_counter<T>(
        w: &T,
        min: u64,
        max: u64,
        clock: &Clock,
        counter: &mut Counter<T>,
        ctx: &mut TxContext
    ): u64 {
        assert!(max > min, EBAD_RANGE);

        let value = from_seed(seed_with_clock_and_counter(w, clock, counter, ctx));

        value % (max - min) + min
    }

    public fun from_seed(seed: vector<u8>): u64 {
        assert!(vector::length(&seed) >= 8, ETOO_FEW_BYTES);
        bcs::peel_u64(&mut bcs::new(seed))
    }

    // generates seed using the tx context (epoch, sender and a newly created uid) and clock 
    public fun seed_with_clock(clock: &Clock, ctx: &mut TxContext): vector<u8> {
        let raw_seed = raw_seed(ctx);

        let timestamp_bytes = bcs::to_bytes(&clock::timestamp_ms(clock));
        vector::append(&mut raw_seed, timestamp_bytes);

        hash::sha3_256(raw_seed)
    }

    // generates seed using the tx context (epoch, sender and a newly created uid) and a counter 
    public fun seed_with_counter<T>(w: &T, counter: &mut Counter<T>, ctx: &mut TxContext): vector<u8> {
        let raw_seed = raw_seed(ctx);

        let counter_bytes = bcs::to_bytes(&counter::increment(counter, w));
        vector::append(&mut raw_seed, counter_bytes);

        hash::sha3_256(raw_seed)
    }

    // generates seed using the tx context (epoch, sender and a newly created uid) and clock 
    public fun seed_with_clock_and_counter<T>(w: &T, clock: &Clock, counter: &mut Counter<T>, ctx: &mut TxContext): vector<u8> {
        let raw_seed = raw_seed(ctx);

        let timestamp_bytes = bcs::to_bytes(&clock::timestamp_ms(clock));
        let counter_bytes = bcs::to_bytes(&counter::increment(counter, w));

        vector::append(&mut raw_seed, timestamp_bytes);
        vector::append(&mut raw_seed, counter_bytes);

        hash::sha3_256(raw_seed)
    }

    // generates seed using the tx context (epoch, sender and a newly created uid)
    public fun seed(ctx: &mut TxContext): vector<u8> {
        let raw_seed = raw_seed(ctx);
        hash::sha3_256(raw_seed)
    }

    public fun raw_seed(ctx: &mut TxContext): vector<u8> {
        let sender = tx_context::sender(ctx);
        let sender_bytes = bcs::to_bytes(&sender);

        let epoch = tx_context::epoch(ctx);
        let epoch_bytes = bcs::to_bytes(&epoch);

        let id = object::new(ctx);
        let id_bytes = object::uid_to_bytes(&id);
        object::delete(id);

        let raw_seed = vector::empty<u8>();
        vector::append(&mut raw_seed, id_bytes);
        vector::append(&mut raw_seed, epoch_bytes);
        vector::append(&mut raw_seed, sender_bytes);

        raw_seed
    }
}
